<!DOCTYPE html>
<html lang="af">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Boogskiet Snelheid</title>

    <!-- PWA and Mobile App Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Snelheid">
    <meta name="theme-color" content="#111827">
    <link rel="apple-touch-icon" href="cropped.png">
    <link rel="manifest" href="manifest.json">
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body {
            touch-action: manipulation;
            background-color: #030712; /* Darker bg for the whole page */
        }
        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .animate-fade-in {
            animation: fade-in 0.3s ease-out forwards;
        }
        .details-marker {
            transition: transform 0.2s ease-in-out;
        }
        details[open] .details-marker {
            transform: rotate(90deg);
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #67e8f9; /* cyan-400 */
            cursor: pointer;
            border-radius: 50%;
            margin-top: -8px; /* Center thumb on track */
        }

        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #67e8f9;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true };
            }

            componentDidCatch(error, errorInfo) {
                this.setState({ error, errorInfo });
                console.error("ErrorBoundary caught an error", error, errorInfo);
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="text-white bg-red-800 p-4 rounded-lg m-4 max-w-md mx-auto">
                            <h1 className="text-xl font-bold">Iets het verkeerd geloop.</h1>
                            <p>Herlaai asseblief die bladsy en probeer weer.</p>
                            {this.state.error && (
                                <pre className="mt-4 text-sm whitespace-pre-wrap bg-red-900 p-2 rounded">
                                    {this.state.error.toString()}
                                </pre>
                            )}
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        const Status = {
            IDLE: 'IDLE',
            RECORDING: 'RECORDING',
            PAUSED: 'PAUSED',
            ROUND_COMPLETE: 'ROUND_COMPLETE',
            ERROR: 'ERROR',
        };

        const PEAK_DETECTION_THRESHOLD = 0.40;
        const MIN_PEAK_SPACING_S = 0.15; // 150ms
        const MAX_PEAK_SPACING_S = 1.5;  // 1.5s
        const SPEED_UNITS = ['m/s', 'FPS', 'km/h'];
        const GRAPH_TIME_WINDOW_S = 0.5;
        const SPEED_OF_SOUND_MS = 343;

        const convertSpeed = (speedInMs, unit) => {
            if (speedInMs === null || isNaN(speedInMs)) return null;
            switch (unit) {
                case 'FPS': return (speedInMs * 3.28084);
                case 'km/h': return (speedInMs * 3.6);
                case 'm/s': default: return speedInMs;
            }
        };

        const calculateSpeed = (distanceMeters, totalTimeSeconds) => {
            if (distanceMeters <= 0 || totalTimeSeconds <= 0) return null;
            
            // Time for sound to travel from target to microphone
            const tSound = distanceMeters / SPEED_OF_SOUND_MS;
            
            // Time for arrow to travel to target
            const tArrow = totalTimeSeconds - tSound;

            // If tArrow is non-positive, the measurement is invalid (e.g., faster than sound or an error)
            if (tArrow <= 0) return null;
            
            const arrowSpeed = distanceMeters / tArrow;
            return arrowSpeed;
        };
        
        const getInitialSession = () => {
            try {
                const savedSession = localStorage.getItem('bowSpeedCurrentSession');
                if (savedSession) {
                    return JSON.parse(savedSession);
                }
            } catch (e) { console.error("Could not parse saved session", e); }
            return null;
        };
        const initialSession = getInitialSession();

        const App = () => {
            const [micInitialized, setMicInitialized] = useState(false);
            const [status, setStatus] = useState(() => {
                if (initialSession?.status) {
                    const { status } = initialSession;
                    if (status === Status.RECORDING || status === Status.PAUSED) return Status.PAUSED;
                    if (status === Status.ROUND_COMPLETE) return Status.ROUND_COMPLETE;
                }
                return Status.IDLE;
            });
            const [distance, setDistance] = useState(() => initialSession?.distance || localStorage.getItem('bowSpeedDistance') || '10');
            const [shotsPerRound, setShotsPerRound] = useState(() => localStorage.getItem('bowShotsPerRound') || '3');
            const [error, setError] = useState('');
            const [sessionShots, setSessionShots] = useState(() => initialSession?.sessionShots || []);
            const [totalTargetShots, setTotalTargetShots] = useState(() => initialSession?.totalTargetShots || 0);
            const [currentShot, setCurrentShot] = useState({ speed: null, timeElapsed: null });
            const [gain, setGain] = useState(() => parseFloat(localStorage.getItem('bowSpeedGain') || '1'));
            
            const [editingShot, setEditingShot] = useState(null);
            const [editedShotData, setEditedShotData] = useState(null);
            const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
            const [canvasCursor, setCanvasCursor] = useState('auto');
            
            const [history, setHistory] = useState(() => {
                try {
                    const savedHistory = localStorage.getItem('bowSpeedHistory');
                    if (!savedHistory) return [];
                    const parsedHistory = JSON.parse(savedHistory);
            
                    if (Array.isArray(parsedHistory)) {
                        return parsedHistory.filter(session => Array.isArray(session?.shots));
                    }
                    return [];
                } catch (error) {
                    console.error("Could not load or parse history from local storage", error);
                    localStorage.removeItem('bowSpeedHistory');
                    return [];
                }
            });
            const [speedUnit, setSpeedUnit] = useState(() => localStorage.getItem('bowSpeedUnit') || SPEED_UNITS[0]);
            const [installPromptEvent, setInstallPromptEvent] = useState(null);

            const audioContextRef = useRef(null);
            const streamRef = useRef(null);
            const gainNodeRef = useRef(null);
            const analyserNodeRef = useRef(null);
            const scriptProcessorRef = useRef(null);
            const animationFrameIdRef = useRef(null);
            const canvasRef = useRef(null);
            const liveCanvasRef = useRef(null);
            const sampleRateRef = useRef(0);
            
            const totalSamplesRef = useRef(0);
            const firstPeakIndexRef = useRef(null);
            const shotWaveformBufferRef = useRef([]);
            const shotToProcessRef = useRef(null);
            const samplesToBufferAfterShotRef = useRef(0);
            const lastShotDisplayRef = useRef(null);
            const draggingPeakRef = useRef(null);

            // --- Local Storage and State Syncing ---
            useEffect(() => {
                try {
                    localStorage.setItem('bowSpeedHistory', JSON.stringify(history));
                    localStorage.setItem('bowSpeedDistance', distance);
                    localStorage.setItem('bowShotsPerRound', shotsPerRound);
                    localStorage.setItem('bowSpeedUnit', speedUnit);
                    localStorage.setItem('bowSpeedGain', gain);
                } catch (error) {
                    console.error("Could not save to local storage", error);
                }
            }, [history, distance, shotsPerRound, speedUnit, gain]);
            
            useEffect(() => {
                if ([Status.RECORDING, Status.PAUSED, Status.ROUND_COMPLETE].includes(status)) {
                    const currentSession = { status, distance, sessionShots, totalTargetShots };
                    try {
                        localStorage.setItem('bowSpeedCurrentSession', JSON.stringify(currentSession));
                    } catch (error) {
                        console.error("Could not save current session", error);
                    }
                } else {
                    localStorage.removeItem('bowSpeedCurrentSession');
                }
            }, [status, distance, sessionShots, totalTargetShots]);

            useEffect(() => {
                if (gainNodeRef.current && audioContextRef.current) {
                    gainNodeRef.current.gain.setValueAtTime(gain, audioContextRef.current.currentTime);
                }
            }, [gain]);

            useEffect(() => {
                if (editingShot && editedShotData) {
                    const dist = parseFloat(distance);
                    if (!isNaN(dist) && dist > 0 && editedShotData.timeElapsed > 0) {
                        const newSpeed = calculateSpeed(dist, editedShotData.timeElapsed);
                        if (newSpeed !== editedShotData.speed) {
                           setEditedShotData(prev => ({ ...prev, speed: newSpeed }));
                        }
                    }
                }
            }, [distance, editingShot, editedShotData]);

            // --- Waveform Drawing ---
            const drawLiveWaveform = useCallback(() => {
                if (!analyserNodeRef.current || !liveCanvasRef.current) {
                    animationFrameIdRef.current = requestAnimationFrame(drawLiveWaveform);
                    return;
                }
                
                const analyser = analyserNodeRef.current;
                const canvas = liveCanvasRef.current;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                const bufferLength = analyser.fftSize;
                const dataArray = new Float32Array(bufferLength);
                analyser.getFloatTimeDomainData(dataArray);
                
                ctx.fillStyle = 'rgb(17 24 39)';
                ctx.fillRect(0, 0, width, height);
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#67e8f9';
                ctx.beginPath();
                const sliceWidth = width * 1.0 / bufferLength;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] * height / 2;
                    const y = height / 2 + v;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.lineTo(width, height / 2);
                ctx.stroke();
                
                animationFrameIdRef.current = requestAnimationFrame(drawLiveWaveform);
            }, []);

            useEffect(() => {
                if (micInitialized) {
                    animationFrameIdRef.current = requestAnimationFrame(drawLiveWaveform);
                }
                return () => {
                    if (animationFrameIdRef.current) {
                        cancelAnimationFrame(animationFrameIdRef.current);
                        animationFrameIdRef.current = null;
                    }
                };
            }, [micInitialized, drawLiveWaveform]);

            const drawHighFidelityWaveform = useCallback((ctx, waveformData, color) => {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const halfHeight = height / 2;
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                const samplesPerPixel = waveformData.length / width;
                ctx.beginPath();
                for (let x = 0; x < width; x++) {
                    const startIndex = Math.floor(x * samplesPerPixel);
                    const endIndex = Math.min(Math.floor((x + 1) * samplesPerPixel), waveformData.length - 1);
                    let min = 1.0, max = -1.0;
                    for (let i = startIndex; i < endIndex; i++) {
                        const sample = waveformData[i] || 0;
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                    if (min > max) { min = 0; max = 0; }
                    ctx.moveTo(x + 0.5, halfHeight + min * halfHeight);
                    ctx.lineTo(x + 0.5, halfHeight + max * halfHeight);
                }
                ctx.stroke();
            }, []);

            const drawShotWaveform = useCallback((waveformData, peak1Index, peak2Index) => {
                const canvas = canvasRef.current;
                if (!canvas || !waveformData || waveformData.length === 0) return;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                ctx.fillStyle = 'rgb(17 24 39)';
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(107, 114, 128, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= 5; i++) {
                    const x = (i / 5) * width;
                    ctx.moveTo(x + 0.5, 0);
                    ctx.lineTo(x + 0.5, height);
                }
                ctx.stroke();
                drawHighFidelityWaveform(ctx, waveformData, '#67e8f9');
                if (peak1Index !== null && peak2Index !== null) {
                    ctx.strokeStyle = '#f87171';
                    ctx.lineWidth = 1.5;
                    const x1 = (peak1Index / waveformData.length) * width;
                    const x2 = (peak2Index / waveformData.length) * width;
                    ctx.beginPath();
                    ctx.moveTo(x1, 0);
                    ctx.lineTo(x1, height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x2, 0);
                    ctx.lineTo(x2, height);
                    ctx.stroke();
                }
            }, [drawHighFidelityWaveform]);

            const clearCanvas = useCallback(() => {
                 const canvas = canvasRef.current;
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = 'rgb(17 24 39)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }, []);
            
            const startSession = useCallback(() => {
                if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
                    audioContextRef.current.resume();
                }
                const distNum = parseFloat(distance);
                const shotsNum = parseInt(shotsPerRound, 10);
                if (isNaN(distNum) || distNum <= 0 || isNaN(shotsNum) || shotsNum <= 0) {
                    setError("Voer asseblief 'n geldige afstand en aantal pyle in.");
                    setStatus(Status.ERROR); return;
                }
                setError('');
                setCurrentShot({ speed: null, timeElapsed: null });
                setSessionShots([]);
                setTotalTargetShots(shotsNum);
                lastShotDisplayRef.current = null;
                setEditingShot(null);
                setEditedShotData(null);
                
                clearCanvas();
                const canvas = canvasRef.current;
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#9ca3af'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText('Luister...', canvas.width / 2, canvas.height / 2);
                }
                
                totalSamplesRef.current = 0;
                firstPeakIndexRef.current = null;
                shotWaveformBufferRef.current = [];
                shotToProcessRef.current = null;
                samplesToBufferAfterShotRef.current = 0;
                setStatus(Status.RECORDING);
            }, [distance, shotsPerRound, clearCanvas]);

            // --- Audio Processing Logic ---
            const stopProcessing = useCallback(() => {
                if (scriptProcessorRef.current) {
                    scriptProcessorRef.current.disconnect();
                    scriptProcessorRef.current.onaudioprocess = null;
                }
            }, []);
            
            const startProcessing = useCallback(() => {
                if (!scriptProcessorRef.current || !gainNodeRef.current || !audioContextRef.current) return;
                
                scriptProcessorRef.current.onaudioprocess = (e) => {
                    if (status !== Status.RECORDING) return;
                    if (totalTargetShots > 0 && sessionShots.length >= totalTargetShots) return;

                    const inputData = e.inputBuffer.getChannelData(0);
                    const currentSampleOffset = totalSamplesRef.current;

                    if (samplesToBufferAfterShotRef.current > 0) {
                        shotWaveformBufferRef.current.push(...inputData);
                        samplesToBufferAfterShotRef.current -= inputData.length;
                        if (samplesToBufferAfterShotRef.current <= 0) {
                            const { timeElapsed, dist, firstPeakIndexInBuffer, secondPeakIndexInBuffer } = shotToProcessRef.current;
                            const speedInMs = calculateSpeed(dist, timeElapsed);
                            const fullWaveform = new Float32Array(shotWaveformBufferRef.current);
                            const peakMidpointInSamples = firstPeakIndexInBuffer + ((secondPeakIndexInBuffer - firstPeakIndexInBuffer) / 2);
                            const displayWidthInSamples = Math.floor(sampleRateRef.current * GRAPH_TIME_WINDOW_S);
                            let startIndex = Math.floor(peakMidpointInSamples - (displayWidthInSamples / 2));
                            let endIndex = startIndex + displayWidthInSamples;
                            if (startIndex < 0) { startIndex = 0; endIndex = displayWidthInSamples; }
                            if (endIndex > fullWaveform.length) { endIndex = fullWaveform.length; startIndex = Math.max(0, endIndex - displayWidthInSamples); }

                            const croppedWaveform = fullWaveform.slice(startIndex, endIndex);
                            const newPeak1Index = firstPeakIndexInBuffer - startIndex;
                            const newPeak2Index = secondPeakIndexInBuffer - startIndex;
                            const newShot = { speed: speedInMs, timeElapsed, waveformData: Array.from(croppedWaveform), peak1Index: newPeak1Index, peak2Index: newPeak2Index };
                            
                            setCurrentShot(newShot);
                            setSessionShots(prev => [...prev, newShot]);
                            lastShotDisplayRef.current = { waveformData: croppedWaveform, peak1Index: newPeak1Index, peak2Index: newPeak2Index };
                            drawShotWaveform(croppedWaveform, newPeak1Index, newPeak2Index);

                            shotToProcessRef.current = null;
                            firstPeakIndexRef.current = null;
                            shotWaveformBufferRef.current = [];
                        }
                    } else {
                        let peakInChunkIndex = -1, peakVal = 0;
                        for (let i = 0; i < inputData.length; i++) {
                            const absVal = Math.abs(inputData[i]);
                            if (absVal > PEAK_DETECTION_THRESHOLD && absVal > peakVal) {
                                peakInChunkIndex = i;
                                peakVal = absVal;
                            }
                        }
                        if (peakInChunkIndex !== -1) {
                            const absolutePeakIndex = currentSampleOffset + peakInChunkIndex;
                            if (firstPeakIndexRef.current === null) {
                                firstPeakIndexRef.current = absolutePeakIndex;
                                shotWaveformBufferRef.current.push(...inputData.slice(peakInChunkIndex));
                            } else {
                                shotWaveformBufferRef.current.push(...inputData);
                                const timeElapsed = (absolutePeakIndex - firstPeakIndexRef.current) / sampleRateRef.current;
                                if (timeElapsed > MIN_PEAK_SPACING_S && timeElapsed < MAX_PEAK_SPACING_S) {
                                    const dist = parseFloat(distance);
                                    shotToProcessRef.current = { timeElapsed, dist, firstPeakIndexInBuffer: 0, secondPeakIndexInBuffer: absolutePeakIndex - firstPeakIndexRef.current };
                                    samplesToBufferAfterShotRef.current = sampleRateRef.current * 0.5;
                                } else if (timeElapsed >= MAX_PEAK_SPACING_S) {
                                    firstPeakIndexRef.current = absolutePeakIndex;
                                    shotWaveformBufferRef.current = [...inputData.slice(peakInChunkIndex)];
                                }
                            }
                        } else {
                            if (firstPeakIndexRef.current !== null) {
                                shotWaveformBufferRef.current.push(...inputData);
                                if (((currentSampleOffset + inputData.length) - firstPeakIndexRef.current) / sampleRateRef.current > MAX_PEAK_SPACING_S) {
                                    firstPeakIndexRef.current = null;
                                    shotWaveformBufferRef.current = [];
                                }
                            }
                        }
                    }
                    totalSamplesRef.current += inputData.length;
                };
                
                gainNodeRef.current.connect(scriptProcessorRef.current);
                scriptProcessorRef.current.connect(audioContextRef.current.destination);
            }, [distance, status, totalTargetShots, sessionShots.length, drawShotWaveform]);

            // Central effect to manage audio processing based on status
            useEffect(() => {
                if (status === Status.RECORDING) {
                    startProcessing();
                } else {
                    stopProcessing();
                }
            }, [status, startProcessing, stopProcessing]);

            const initializeAudio = useCallback(async () => {
                try {
                    const context = new (window.AudioContext || window.webkitAudioContext)();
                    audioContextRef.current = context;

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                    
                    if (context.state === 'suspended') {
                        await context.resume();
                    }
                    
                    streamRef.current = stream;
                    sampleRateRef.current = context.sampleRate;
                    
                    const source = context.createMediaStreamSource(stream);
                    const gainNode = context.createGain();
                    gainNode.gain.setValueAtTime(gain, context.currentTime);
                    gainNodeRef.current = gainNode;
                    
                    const analyser = context.createAnalyser();
                    analyser.fftSize = 2048;
                    analyserNodeRef.current = analyser;
                    
                    scriptProcessorRef.current = context.createScriptProcessor(4096, 1, 1);

                    source.connect(gainNode);
                    gainNode.connect(analyser);

                    setMicInitialized(true);
                } catch (err) {
                    console.error(err);
                    setError("Mikrofoon toegang geweier. Laat asseblief toegang toe in jou blaaier se instellings.");
                    setStatus(Status.ERROR);
                }
            }, [gain]);

            useEffect(() => {
                if (!micInitialized) {
                    initializeAudio();
                }
            }, [initializeAudio, micInitialized]);

            // Full audio system cleanup on component unmount
            useEffect(() => {
                return () => {
                    if (streamRef.current) streamRef.current.getTracks().forEach(track => track.stop());
                    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
                        audioContextRef.current.close();
                    }
                };
            }, []);

             useEffect(() => {
                if (status === Status.RECORDING && totalTargetShots > 0 && sessionShots.length >= totalTargetShots) {
                    setStatus(Status.ROUND_COMPLETE);
                }
            }, [sessionShots.length, totalTargetShots, status]);
            
            useEffect(() => {
                const handleBeforeInstallPrompt = (e) => {
                    e.preventDefault();
                    setInstallPromptEvent(e);
                };
                const handleAppInstalled = () => {
                    setInstallPromptEvent(null);
                };
                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                window.addEventListener('appinstalled', handleAppInstalled);
                return () => {
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, []);

            const handleInstallClick = async () => {
                if (!installPromptEvent) return;
                installPromptEvent.prompt();
                await installPromptEvent.userChoice;
                setInstallPromptEvent(null);
            };

            // --- Session Control Handlers ---
            const saveSessionToHistory = useCallback(() => {
                if (sessionShots.length > 0) {
                    const validShots = sessionShots.filter(s => s.speed !== null && s.speed > 0);
                    if (validShots.length === 0) return; // Don't save a session with no valid shots
                    const averageSpeed = validShots.reduce((acc, s) => acc + s.speed, 0) / validShots.length;
                    const newEntry = { id: Date.now(), createdAt: new Date().toISOString(), distance: parseFloat(distance), averageSpeed: averageSpeed, shots: [...sessionShots] };
                    setHistory(prev => [newEntry, ...prev]);
                }
            }, [sessionShots, distance]);
            
            const stopAndSave = useCallback(() => {
                saveSessionToHistory();
                setStatus(Status.IDLE);
                setSessionShots([]);
                setTotalTargetShots(0);
                setCurrentShot({ speed: null, timeElapsed: null });
            }, [saveSessionToHistory]);
            
            const handlePause = () => {
                 if (audioContextRef.current && audioContextRef.current.state === 'running') {
                    audioContextRef.current.suspend();
                }
                setStatus(Status.PAUSED);
            };

            const handleContinue = () => {
                if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
                    audioContextRef.current.resume();
                }
                setStatus(Status.RECORDING);
            };

            const handleEndSession = () => {
                if(sessionShots.length > 0) saveSessionToHistory();
                setSessionShots([]);
                setTotalTargetShots(0);
                setCurrentShot({ speed: null, timeElapsed: null });
                setStatus(Status.IDLE);
                setEditingShot(null);
                setEditedShotData(null);
                clearCanvas();
            };

            const handleAddOneShot = () => {
                const newTotalTarget = sessionShots.length + 1;
                setTotalTargetShots(newTotalTarget);
                setStatus(Status.RECORDING);
            };

            const handleNextRound = () => {
                const nextRoundSize = parseInt(shotsPerRound, 10);
                if (isNaN(nextRoundSize) || nextRoundSize <= 0) {
                    setError("Voer 'n geldige aantal pyle in vir die volgende rondte."); return;
                }
                setError('');
                const newTotal = sessionShots.length + nextRoundSize;
                setTotalTargetShots(newTotal);
                setStatus(Status.RECORDING);
            };
            
            // --- Editing and History Handlers ---
            const handleUnitCycle = () => setSpeedUnit(SPEED_UNITS[(SPEED_UNITS.indexOf(speedUnit) + 1) % SPEED_UNITS.length]);
            
            const handleEditShot = useCallback((sessionId, shotIndex) => {
                if(status === Status.RECORDING || status === Status.PAUSED) return;
                const session = history.find(s => s.id === sessionId);
                if(!session) return;
                const shot = session.shots[shotIndex];
                if(!shot) return;
                handleEndSession();
                setDistance(session.distance.toString());
                setEditedShotData({ ...shot });
                setEditingShot({ sessionId, shotIndex });
                drawShotWaveform(shot.waveformData, shot.peak1Index, shot.peak2Index);
            }, [history, status, drawShotWaveform, handleEndSession]);
            
            const handleSaveEdit = () => {
                if (!editingShot || !editedShotData) return;
                const { sessionId, shotIndex } = editingShot;
                const newHistory = history.map(session => {
                    if (session.id === sessionId) {
                        const newShots = [...session.shots];
                        newShots[shotIndex] = editedShotData;
                        const validShots = newShots.filter(s => s.speed !== null && s.speed > 0);
                        const newAverageSpeed = validShots.length > 0 ? validShots.reduce((acc, s) => acc + s.speed, 0) / validShots.length : 0;
                        return { ...session, distance: parseFloat(distance), shots: newShots, averageSpeed: newAverageSpeed };
                    }
                    return session;
                });
                setHistory(newHistory);
                setEditingShot(null); setEditedShotData(null); clearCanvas();
            };

            const handleConfirmDelete = () => {
                if (!editingShot) return;
                const { sessionId, shotIndex } = editingShot;
                const newHistory = history.map(session => {
                    if (session.id === sessionId) {
                        const newShots = session.shots.filter((_, index) => index !== shotIndex);
                        if (newShots.length === 0) return null; // Mark for removal
                        const validShots = newShots.filter(s => s.speed !== null && s.speed > 0);
                        const newAverageSpeed = validShots.length > 0 ? validShots.reduce((acc, s) => acc + s.speed, 0) / validShots.length : 0;
                        return { ...session, shots: newShots, averageSpeed: newAverageSpeed };
                    }
                    return session;
                }).filter(Boolean);
                setHistory(newHistory);
                setShowDeleteConfirm(false); setEditingShot(null); setEditedShotData(null); clearCanvas();
            };
            
            // --- Canvas Interaction Handlers ---
            const getEventX = useCallback((e) => {
                const clientX = e.touches?.[0]?.clientX ?? e.clientX;
                if (clientX === undefined) return null;
                const canvas = canvasRef.current;
                if (!canvas) return null;
                const rect = canvas.getBoundingClientRect();
                return (clientX - rect.left) * (canvas.width / rect.width);
            }, []);

            const handleCanvasPointerDown = useCallback((e) => {
                if (!editingShot) return;
                const x = getEventX(e);
                if (x === null) return;
                const { peak1Index, peak2Index, waveformData } = editedShotData;
                const x1 = (peak1Index / waveformData.length) * canvasRef.current.width;
                const x2 = (peak2Index / waveformData.length) * canvasRef.current.width;
                const hitbox = 20;
                if (Math.abs(x - x1) < hitbox) draggingPeakRef.current = 'peak1';
                else if (Math.abs(x - x2) < hitbox) draggingPeakRef.current = 'peak2';
                if (draggingPeakRef.current) setCanvasCursor('col-resize');
            }, [editingShot, editedShotData, getEventX]);

            const handleCanvasPointerMove = useCallback((e) => {
                if (!editingShot) return;
                if (draggingPeakRef.current && e.cancelable) e.preventDefault();
                const x = getEventX(e);
                if (x === null) return;
                const { waveformData, peak1Index, peak2Index } = editedShotData;
                const canvasWidth = canvasRef.current.width;
                if (draggingPeakRef.current) {
                    let newIndex = Math.max(0, Math.min(waveformData.length - 1, Math.round((x / canvasWidth) * waveformData.length)));
                    let newPeak1 = peak1Index, newPeak2 = peak2Index;
                    if (draggingPeakRef.current === 'peak1' && newIndex < peak2Index) newPeak1 = newIndex;
                    else if (draggingPeakRef.current === 'peak2' && newIndex > peak1Index) newPeak2 = newIndex;
                    if (newPeak1 !== peak1Index || newPeak2 !== peak2Index) {
                        const timePerSample = GRAPH_TIME_WINDOW_S / waveformData.length;
                        const newTimeElapsed = (newPeak2 - newPeak1) * timePerSample;
                        const dist = parseFloat(distance);
                        const newSpeed = calculateSpeed(dist, newTimeElapsed);
                        const newEditedData = { ...editedShotData, peak1Index: newPeak1, peak2Index: newPeak2, timeElapsed: newTimeElapsed, speed: newSpeed };
                        setEditedShotData(newEditedData);
                        drawShotWaveform(newEditedData.waveformData, newEditedData.peak1Index, newEditedData.peak2Index);
                    }
                } else {
                    const x1 = (peak1Index / waveformData.length) * canvasWidth, x2 = (peak2Index / waveformData.length) * canvasWidth;
                    setCanvasCursor(Math.abs(x - x1) < 20 || Math.abs(x - x2) < 20 ? 'col-resize' : 'auto');
                }
            }, [editingShot, editedShotData, distance, drawShotWaveform, getEventX]);

            const handleCanvasPointerUp = useCallback(() => {
                if (draggingPeakRef.current) {
                    draggingPeakRef.current = null; setCanvasCursor('auto');
                }
            }, []);

            if (!micInitialized) {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center p-4 text-center">
                        <div className="w-full max-w-md mx-auto bg-gray-800 rounded-2xl shadow-2xl p-8 space-y-6">
                            <h1 className="text-3xl font-bold text-cyan-400">Boogskiet Snelheid</h1>
                            <p className="text-gray-300">
                                {error ? "Kon nie mikrofoon inisialiseer nie." : "Inisialiseer mikrofoon..."}
                            </p>
                            {!error && <p className="text-gray-400 text-sm">Laat asseblief toegang tot die mikrofoon toe wanneer jou blaaier vra.</p>}
                            {error && <p className="text-red-400 font-semibold pt-4">{error}</p>}
                        </div>
                    </div>
                );
            }
            
            const speedToDisplay = editingShot ? editedShotData.speed : currentShot.speed;
            const timeElapsedToDisplay = editingShot ? editedShotData?.timeElapsed : currentShot?.timeElapsed;
            const currentSpeedDisplay = convertSpeed(speedToDisplay, speedUnit);
            const isSessionActive = status === Status.RECORDING || status === Status.PAUSED || status === Status.ROUND_COMPLETE;
            
            return (
                <div className="min-h-screen flex flex-col items-center p-4">
                    <div className="w-full max-w-md mx-auto bg-gray-800 rounded-2xl shadow-2xl p-6 md:p-8 space-y-4 text-center">
                        <img src="Untitled.png" alt="Boogskiet Snelheid" className="w-3/4 mx-auto mb-2" />
                        
                        {/* Group 1: Speed, Arrow Count, Shot Waveform */}
                        <div className="bg-gray-700/50 border border-gray-600 p-4 rounded-xl space-y-4">
                            <div className="grid grid-cols-2 gap-4">
                                <div className="cursor-pointer" onClick={handleUnitCycle} title="Klik om eenhede te verander">
                                    <p className="text-sm text-gray-400 uppercase">{editingShot ? 'Gewysigde Spoed' : 'Huidige Spoed'}</p>
                                    <p className="text-4xl font-bold text-white">{currentSpeedDisplay !== null ? currentSpeedDisplay.toFixed(2) : '--'}</p>
                                     <div className="flex justify-center space-x-2 mt-1 text-base">
                                        {SPEED_UNITS.map(unit => (<span key={unit} className={`font-semibold transition-colors ${speedUnit === unit ? 'text-cyan-400' : 'text-gray-500'}`}>{unit}</span>))}
                                    </div>
                                </div>
                                <div>
                                    <p className="text-sm text-gray-400 uppercase">Pyle Geskiet</p>
                                    <p className="text-4xl font-bold text-white">{sessionShots.length}</p>
                                    <p className="text-base text-gray-300 mt-1 invisible">{speedUnit}</p>
                                </div>
                            </div>

                            <div>
                                <p className="text-sm text-gray-400 uppercase mb-1">
                                     {timeElapsedToDisplay && timeElapsedToDisplay > 0
                                        ? `Vlugtyd: ${(timeElapsedToDisplay * 1000).toFixed(1)} ms`
                                        : 'Klankbaan'}
                                </p>
                                <canvas 
                                    ref={canvasRef} 
                                    width="400" 
                                    height="75" 
                                    className="bg-gray-900 rounded-lg w-full"
                                    style={{ cursor: editingShot ? canvasCursor : 'default', touchAction: 'none' }}
                                    onMouseDown={handleCanvasPointerDown} onMouseMove={handleCanvasPointerMove} onMouseUp={handleCanvasPointerUp}
                                    onMouseLeave={handleCanvasPointerUp} onTouchStart={handleCanvasPointerDown} onTouchMove={handleCanvasPointerMove}
                                    onTouchEnd={handleCanvasPointerUp}
                                ></canvas>
                                 <div className="flex justify-between text-xs text-gray-400 px-1 mt-1">
                                    <span>0.0s</span><span>0.1s</span><span>0.2s</span><span>0.3s</span><span>0.4s</span><span>0.5s</span>
                                </div>
                            </div>
                        </div>
                        
                        {/* Group 2: Live Audio, Mic Gain OR Edit Buttons */}
                        {!editingShot ? (
                            <div className="bg-gray-700/50 border border-gray-600 p-4 rounded-xl space-y-4">
                                <div>
                                    <p className="text-sm text-gray-400 uppercase mb-1">Huidige Klank</p>
                                    <canvas ref={liveCanvasRef} width="400" height="75" className="bg-gray-900 rounded-lg w-full"></canvas>
                                </div>
                                <div>
                                    <label htmlFor="gain" className="block text-base font-medium text-gray-300 mb-2">Mikrofoon Versterking</label>
                                    <input
                                        type="range" id="gain" min="0.1" max="5" step="0.1" value={gain}
                                        onChange={(e) => setGain(parseFloat(e.target.value))}
                                        className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                            </div>
                        ) : (
                            <div className="bg-gray-700/50 border border-gray-600 p-4 rounded-xl grid grid-cols-2 gap-4">
                                <button onClick={handleSaveEdit} className="w-full text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-green-600 hover:bg-green-700">Stoor</button>
                                <button onClick={() => setShowDeleteConfirm(true)} className="w-full text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-red-600 hover:bg-red-700">Verwyder</button>
                            </div>
                        )}
                        
                        {/* Group 3: Inputs and Action Buttons */}
                        <div className="bg-gray-700/50 border border-gray-600 p-4 rounded-xl space-y-4">
                            <div className="flex gap-4">
                                <div className="flex-1">
                                    <label htmlFor="distance" className="block text-base font-medium text-gray-300 mb-2">Afstand (m)</label>
                                    <div className={`flex items-stretch w-full bg-gray-700 border-2 border-gray-600 rounded-lg transition ${isSessionActive ? 'bg-gray-700/50 cursor-not-allowed' : 'focus-within:ring-2 focus-within:ring-cyan-500 focus-within:border-cyan-500'}`}>
                                        <button
                                            onClick={() => setDistance(d => Math.max(1, (parseInt(d, 10) || 0) - 1).toString())}
                                            disabled={isSessionActive}
                                            className="px-4 text-2xl font-bold text-cyan-400 border-r border-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed focus:outline-none"
                                            aria-label="Verminder afstand"
                                        >-</button>
                                        <input 
                                            type="number" id="distance" value={distance} 
                                            onChange={(e) => setDistance(e.target.value)}
                                            onBlur={(e) => { if (!e.target.value || parseInt(e.target.value, 10) <= 0) { setDistance('1'); } }}
                                            readOnly={isSessionActive}
                                            className="w-full p-3 text-center text-xl bg-transparent text-white focus:outline-none transition read-only:cursor-not-allowed appearance-none [-moz-appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                        />
                                        <button
                                            onClick={() => setDistance(d => ((parseInt(d, 10) || 0) + 1).toString())}
                                            disabled={isSessionActive}
                                            className="px-4 text-2xl font-bold text-cyan-400 border-l border-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed focus:outline-none"
                                            aria-label="Verhoog afstand"
                                        >+</button>
                                    </div>
                                </div>
                                <div className="flex-1">
                                    <label htmlFor="shots" className="block text-base font-medium text-gray-300 mb-2">Aantal Pyle</label>
                                    <div className={`flex items-stretch w-full bg-gray-700 border-2 border-gray-600 rounded-lg transition ${isSessionActive || editingShot ? 'bg-gray-700/50 cursor-not-allowed' : 'focus-within:ring-2 focus-within:ring-cyan-500 focus-within:border-cyan-500'}`}>
                                        <button
                                            onClick={() => setShotsPerRound(s => Math.max(1, (parseInt(s, 10) || 0) - 1).toString())}
                                            disabled={isSessionActive || editingShot}
                                            className="px-4 text-2xl font-bold text-cyan-400 border-r border-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed focus:outline-none"
                                            aria-label="Verminder aantal pyle"
                                        >-</button>
                                        <input 
                                            type="number" id="shots" value={shotsPerRound} 
                                            onChange={(e) => setShotsPerRound(e.target.value)}
                                            onBlur={(e) => { if (!e.target.value || parseInt(e.target.value, 10) <= 0) { setShotsPerRound('1'); } }}
                                            readOnly={isSessionActive || editingShot}
                                            className="w-full p-3 text-center text-xl bg-transparent text-white focus:outline-none transition read-only:cursor-not-allowed appearance-none [-moz-appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                                        />
                                        <button
                                            onClick={() => setShotsPerRound(s => ((parseInt(s, 10) || 0) + 1).toString())}
                                            disabled={isSessionActive || editingShot}
                                            className="px-4 text-2xl font-bold text-cyan-400 border-l border-gray-600 disabled:text-gray-500 disabled:cursor-not-allowed focus:outline-none"
                                            aria-label="Verhoog aantal pyle"
                                        >+</button>
                                    </div>
                                </div>
                            </div>
                            {status === Status.IDLE || status === Status.ERROR ? (
                                <button onClick={startSession} className="w-full flex items-center justify-center text-white text-xl font-bold py-4 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-opacity-50 bg-green-600 hover:bg-green-700">
                                    Begin
                                </button>
                             ) : status === Status.RECORDING || status === Status.PAUSED ? (
                                <div className="grid grid-cols-2 gap-4">
                                    {status === Status.RECORDING ? (
                                        <button onClick={handlePause} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-yellow-600 hover:bg-yellow-700">Pouse</button>
                                    ) : (
                                        <button onClick={handleContinue} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-blue-600 hover:bg-blue-700">Gaan Voort</button>
                                    )}
                                    <button onClick={stopAndSave} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-red-600 hover:bg-red-600">Stop en Stoor</button>
                                </div>
                             ) : status === Status.ROUND_COMPLETE && (
                                <div className="text-center">
                                    <p className="text-lg text-gray-300 mb-4">Rondte Voltooi!</p>
                                    <div className="space-y-3">
                                        <button onClick={handleNextRound} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-green-600 hover:bg-green-700">Volgende {shotsPerRound} pyle</button>
                                        <div className="grid grid-cols-2 gap-3">
                                            <button onClick={handleAddOneShot} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-blue-600 hover:bg-blue-700">+1</button>
                                            <button onClick={handleEndSession} className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-gray-600 hover:bg-gray-700">Eindig</button>
                                        </div>
                                    </div>
                                </div>
                             )}
                        </div>
                        {error && <p className="text-red-400 font-semibold pt-2">{error}</p>}
                    </div>
                    
                    {history.length > 0 && (
                        <div className="w-full max-w-md mx-auto mt-8 mb-4">
                            <h2 className="text-xl font-bold text-cyan-400 text-center mb-4">Vorige Sessies</h2>
                            <div className="space-y-3 max-h-96 overflow-y-auto pr-2">
                                {history.map(session => {
                                    const convertedAvgSpeed = convertSpeed(session.averageSpeed, speedUnit);
                                    return (
                                    <details key={session.id} className="bg-gray-800 rounded-lg overflow-hidden animate-fade-in">
                                        <summary className="p-4 cursor-pointer list-none flex justify-between items-center">
                                            <div className="text-left">
                                                <div className="text-xs text-gray-400">{new Date(session.createdAt).toLocaleDateString()}</div>
                                                <div className="text-md font-semibold mt-1">{session.distance}m &middot; {session.shots.length} Pyle</div>
                                            </div>
                                            <div className="flex items-center text-right">
                                                <div className="text-cyan-400 text-2xl font-bold">{convertedAvgSpeed !== null ? convertedAvgSpeed.toFixed(2) : '--'} {speedUnit}</div>
                                                <div className="details-marker text-cyan-400 transform transition-transform duration-200 ml-4">&#x276F;</div>
                                            </div>
                                        </summary>
                                        <div className="bg-gray-900/50 p-4 border-t border-gray-700">
                                            <h4 className="font-semibold mb-2">Individuele Pyle:</h4>
                                            <div className="grid grid-cols-3 sm:grid-cols-4 gap-2 text-sm">
                                                {session.shots.map((shot, index) => {
                                                    const convertedShotSpeed = convertSpeed(shot.speed, speedUnit);
                                                    const canEdit = status !== Status.RECORDING && status !== Status.PAUSED && status !== Status.ROUND_COMPLETE;
                                                    return (
                                                        <div key={index} onClick={() => canEdit && handleEditShot(session.id, index)} className={`bg-gray-700 p-2 rounded-md text-center ${canEdit ? 'cursor-pointer hover:bg-gray-600' : ''}`}>
                                                            <div className="text-xs text-gray-400">Pyl {index + 1}</div>
                                                            <div className="font-semibold">{convertedShotSpeed !== null ? convertedShotSpeed.toFixed(1) : '--'}</div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    </details>
                                )})}
                            </div>
                        </div>
                    )}

                    {installPromptEvent && (
                        <div className="w-full max-w-md mx-auto mt-4 mb-4">
                            <button 
                                onClick={handleInstallClick} 
                                className="w-full flex items-center justify-center text-white text-lg font-bold py-3 px-4 rounded-lg transition duration-300 bg-blue-600 hover:bg-blue-700"
                            >
                                Installeer
                            </button>
                        </div>
                    )}
                    
                    {showDeleteConfirm && (
                        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 animate-fade-in">
                            <div className="bg-gray-800 rounded-lg p-6 shadow-xl text-center">
                                <h3 className="text-lg font-bold mb-4">Bevestig Verwydering</h3>
                                <p className="text-gray-300 mb-6">Is jy seker jy wil hierdie pyl verwyder?</p>
                                <div className="flex justify-center gap-4">
                                    <button onClick={() => setShowDeleteConfirm(false)} className="py-2 px-6 bg-gray-600 hover:bg-gray-700 rounded-lg transition">Nee</button>
                                    <button onClick={handleConfirmDelete} className="py-2 px-6 bg-red-600 hover:bg-red-700 rounded-lg transition">Ja, Verwyder</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(<ErrorBoundary><App /></ErrorBoundary>);
        }
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
    </script>
</body>
</html>
